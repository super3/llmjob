name: Update Stats

on:
  schedule:
    # Run every 24 hours at midnight UTC
    - cron: '0 0 * * *'
  workflow_dispatch: # Allow manual trigger
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/stats.yml'

jobs:
  update-stats:
    runs-on: ubuntu-latest
    
    steps:      
      - name: Fetch Clerk stats and update Gist
        env:
          CLERK_SECRET_KEY: ${{ secrets.CLERK_SECRET_KEY }}
          # Use GIST_TOKEN if available, otherwise fall back to GITHUB_TOKEN
          GITHUB_TOKEN: ${{ secrets.GIST_TOKEN || secrets.GITHUB_TOKEN }}
          GIST_ID: d5792cdd581c2cfef9b7c02c7b866179
        run: |
          # Create a Node.js script to fetch stats and update Gist
          cat > update-stats.js << 'EOF'
          const https = require('https');

          const CLERK_SECRET_KEY = process.env.CLERK_SECRET_KEY;
          const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
          const GIST_ID = process.env.GIST_ID;

          if (!CLERK_SECRET_KEY || !GITHUB_TOKEN || !GIST_ID) {
            console.error('Required environment variables are not set');
            process.exit(1);
          }

          // Fetch node stats from API
          function fetchNodeStats() {
            return new Promise((resolve, reject) => {
              const options = {
                hostname: 'llmjob-production.up.railway.app',
                path: '/api/nodes/public',
                method: 'GET',
                headers: {
                  'Content-Type': 'application/json'
                }
              };

              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                  try {
                    const response = JSON.parse(data);
                    // Use totalOnline count which includes both public and private nodes
                    const onlineNodes = response.totalOnline || 0;
                    resolve(onlineNodes);
                  } catch (error) {
                    console.error('Failed to fetch node stats:', error);
                    resolve(0);
                  }
                });
              });

              req.on('error', (error) => {
                console.error('Failed to fetch node stats:', error);
                resolve(0);
              });
              req.end();
            });
          }

          // Fetch stats from Clerk
          function fetchClerkStats(nodeCount) {
            return new Promise((resolve, reject) => {
              const options = {
                hostname: 'api.clerk.com',
                path: '/v1/users?limit=1',
                method: 'GET',
                headers: {
                  'Authorization': `Bearer ${CLERK_SECRET_KEY}`,
                  'Content-Type': 'application/json'
                }
              };

              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                  try {
                    const response = JSON.parse(data);
                    
                    // Log the Clerk API response for debugging
                    if (res.statusCode !== 200) {
                      console.log('Clerk API error:', res.statusCode, data);
                    }
                    
                    // Log all headers for debugging
                    console.log('Response headers:', JSON.stringify(res.headers));
                    
                    // Clerk returns the total count in the X-Total-Count header
                    const userCount = parseInt(res.headers['x-total-count'] || '0', 10);
                    console.log('Clerk API response - Total users from header:', userCount);
                    console.log('Response body (first user):', JSON.stringify(response[0]).substring(0, 100));
                    
                    const stats = {
                      users: userCount,
                      timestamp: new Date().toISOString(),
                      tokens_processed: "1.2M",
                      models_available: 2,
                      online_nodes: nodeCount
                    };
                    
                    resolve(stats);
                  } catch (error) {
                    console.error('Failed to parse Clerk response:', error);
                    console.error('Response data:', data);
                    reject(error);
                  }
                });
              });

              req.on('error', reject);
              req.end();
            });
          }

          // Update GitHub Gist
          function updateGist(stats) {
            return new Promise((resolve, reject) => {
              const data = JSON.stringify({
                files: {
                  'llmjob-stats.json': {
                    content: JSON.stringify(stats, null, 2)
                  }
                }
              });

              const options = {
                hostname: 'api.github.com',
                path: `/gists/${GIST_ID}`,
                method: 'PATCH',
                headers: {
                  'Authorization': `token ${GITHUB_TOKEN}`,
                  'Content-Type': 'application/json',
                  'User-Agent': 'LLMJob-Stats-Updater',
                  'Content-Length': data.length
                }
              };

              const req = https.request(options, (res) => {
                let response = '';
                res.on('data', (chunk) => response += chunk);
                res.on('end', () => {
                  if (res.statusCode === 200) {
                    console.log('Gist updated successfully');
                    resolve();
                  } else {
                    reject(new Error(`Failed to update gist: ${res.statusCode} - ${response}`));
                  }
                });
              });

              req.on('error', reject);
              req.write(data);
              req.end();
            });
          }

          // Main execution
          let statsData = null;
          fetchNodeStats()
            .then(nodeCount => {
              console.log('Node count fetched:', nodeCount);
              return fetchClerkStats(nodeCount);
            })
            .then(stats => {
              statsData = stats;
              console.log('Stats fetched:', stats);
              return updateGist(stats);
            })
            .then(() => console.log('Stats successfully updated in Gist'))
            .catch(error => {
              console.error('Warning: Could not update Gist (this is expected without a PAT):', error.message);
              if (statsData) {
                console.log('Stats data:', JSON.stringify(statsData, null, 2));
              }
              // Don't fail the workflow - just log the stats
              process.exit(0);
            });
          EOF
          
          # Run the script
          node update-stats.js